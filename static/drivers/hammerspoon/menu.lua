local M = {}
local hs = hs
local image = hs.image
local menubar = hs.menubar
local pathwatcher = hs.pathwatcher

function M.start(base_dir, hotfiles, gestures, scroll, keymap, shortcuts)
    base_dir = base_dir or (hs.configdir .. "/")
    local gen_dir = base_dir .. "generated_hotstrings/"

    -- try to load descriptions generated by the Python script
    local descriptions = {}
    local ok, res = pcall(function() return dofile(gen_dir .. "_descriptions.lua") end)
    if ok and type(res) == "table" then descriptions = res end

    local myMenu = menubar.new()

    local function isDarkMode()
            local ok, out = pcall(function()
                return hs.execute('defaults read -g AppleInterfaceStyle 2>/dev/null')
            end)
            if not ok or not out then return false end
            return out:match("Dark") ~= nil
        end

        local function make_icon(base_dir)
            local logo_file = isDarkMode() and "logo_black.png" or "logo_white.png"
            local icon_path = base_dir .. "images/" .. logo_file
            local icon = image.imageFromPath(icon_path)
            if icon then
                pcall(function()
                    if icon.setSize then icon:setSize({w=18, h=18}) end
                end)
                return icon, icon_path
            end
            return nil, icon_path
        end

        local icon, icon_path = make_icon(base_dir)
        if icon then
            myMenu:setIcon(icon, false)
            print("menu icon loaded:", icon_path)
        else
            myMenu:setTitle("ðŸ”¨")
            print("menu icon NOT loaded, tried:", icon_path)
        end

    -- helper to show notification before reloading Hammerspoon
    local function do_reload(source)
        -- source == "watcher" -> show a system notification
        if source == "watcher" then
            if hs and hs.notify and hs.notify.new then
                pcall(function()
                    hs.notify.new({title = "Hammerspoon", informativeText = "Fichiers modifiÃ©s â€” rechargement de la config"}):send()
                end)
            else
                if hs and hs.alert and hs.alert.show then hs.alert.show("Fichiers modifiÃ©s â€” rechargementâ€¦", 1.0) end
            end
        else
            if hs and hs.alert and hs.alert.show then
                hs.alert.show("Rechargement Hammerspoonâ€¦", 1.0)
            end
        end
        if hs and hs.timer and hs.timer.doAfter then
            hs.timer.doAfter(0.25, function() hs.reload() end)
        else
            hs.reload()
        end
    end

    -- Current module state
    local state = {
        keymap = true,
        gestures = true,
        scroll = true,
        shortcuts = true
    }

    state.hotstrings = {}
    for _, f in ipairs(hotfiles or {}) do
        local name = f:match("^(.*)%.lua$") or f
        state.hotstrings[name] = true
    end
    -- Preferences persistence
    local prefs_file = base_dir .. "ergopti_prefs.json"

    local function load_prefs()
        local fh = io.open(prefs_file, "r")
        if not fh then return {} end
        local content = fh:read("*a")
        fh:close()
        local ok, tbl = pcall(function() return hs.json.decode(content) end)
        if ok and type(tbl) == "table" then return tbl end
        return {}
    end

    local function save_prefs()
        local prefs = {
            keymap = state.keymap,
            gestures = state.gestures,
            scroll = state.scroll,
            shortcuts = state.shortcuts,
            hotstrings = state.hotstrings,
            shortcut_keys = {},
            gesture_map = {}
        }
        -- collect current shortcut key states if module available
        if shortcuts and type(shortcuts.list_shortcuts) == "function" then
            local list = shortcuts.list_shortcuts()
            for _, s in ipairs(list) do
                prefs.shortcut_keys[s.id] = s.enabled
            end
        end
        -- collect gesture states for known gestures
        local gesture_keys = {"tap_selection","tap_lookup","swipe_left","swipe_right","swipe_up","swipe_down","swipe4_left","swipe4_right","swipe5_left","swipe5_right"}
        if gestures and type(gestures.is_enabled) == "function" then
            for _, g in ipairs(gesture_keys) do prefs.gesture_map[g] = gestures.is_enabled(g) end
        end
        local ok, encoded = pcall(function() return hs.json.encode(prefs) end)
        if not ok or not encoded then return end
        local fh = io.open(prefs_file, "w")
        if not fh then return end
        fh:write(encoded)
        fh:close()
    end

    -- Apply saved preferences (if any)
    do
        local saved = load_prefs()
        if type(saved) == "table" then
            if saved.keymap ~= nil then state.keymap = saved.keymap end
            if saved.gestures ~= nil then state.gestures = saved.gestures end
            if saved.scroll ~= nil then state.scroll = saved.scroll end
            if saved.shortcuts ~= nil then state.shortcuts = saved.shortcuts end
            if type(saved.hotstrings) == "table" then
                for name, _ in pairs(state.hotstrings) do
                    if saved.hotstrings[name] ~= nil then state.hotstrings[name] = saved.hotstrings[name] end
                end
            end
        end
    end
    -- Note: do NOT overwrite saved `state.hotstrings` with runtime groups here.
    -- The saved preferences are the source of truth on startup; the menu will
    -- read runtime state dynamically when rendering items.
    -- Start/stop modules according to state and apply per-feature prefs
    do
        -- keymap
        if state.keymap then keymap.start() else keymap.stop() end
        -- gestures: if saved gesture map exists we apply per-gesture, otherwise use enable/disable all
        local saved = load_prefs()
        if type(saved) == "table" and type(saved.gesture_map) == "table" then
            -- ensure gestures module is in a known state before applying individual toggles
            for _, g in ipairs({"tap_selection","tap_lookup","swipe_left","swipe_right","swipe_up","swipe_down","swipe4_left","swipe4_right","swipe5_left","swipe5_right"}) do
                if saved.gesture_map[g] then gestures.enable(g) else gestures.disable(g) end
            end
        else
            if state.gestures then gestures.enable("all") else gestures.disable("all") end
        end
        -- scroll
        if state.scroll then scroll.start() else scroll.stop() end
        -- shortcuts
        if state.shortcuts then shortcuts.start() else shortcuts.stop() end
        -- apply hotstrings groups
        for name, enabled in pairs(state.hotstrings) do
            if enabled then keymap.enable_group(name) else keymap.disable_group(name) end
        end
        -- apply saved shortcut keys if present
        if type(saved) == "table" and type(saved.shortcut_keys) == "table" then
            for id, enabled in pairs(saved.shortcut_keys) do
                if enabled then shortcuts.enable(id) else shortcuts.disable(id) end
            end
        end
        -- persist current state after applying
        save_prefs()
    end
    -- utility functions to build menu items

    local function buildHotstringsItem()
        local item = {
            title = "Expansion de texte",
            checked = state.keymap or nil,
                fn = function()
                state.keymap = not state.keymap
                if state.keymap then keymap.start() else keymap.stop() end
                save_prefs()
                do_reload()
            end
        }
        if state.keymap then
            item.menu = (function()
                local normal_menu = {}
                local plus_menu = {}
                for _, f in ipairs(hotfiles or {}) do
                    local name = f:match("^(.*)%.lua$") or f
                    local pretty = name:gsub("_"," ")
                    if descriptions[name] and descriptions[name] ~= "" then
                        pretty = descriptions[name]
                    end
                    local entry = {
                        title = pretty,
                        checked = (keymap and type(keymap.is_group_enabled) == "function" and keymap.is_group_enabled(name)) or state.hotstrings[name] or nil,
                        fn = function()
                            state.hotstrings[name] = not state.hotstrings[name]
                            if state.hotstrings[name] then keymap.enable_group(name) else keymap.disable_group(name) end
                            save_prefs()
                            do_reload()
                        end
                    }
                    if name:match("^plus") then
                        table.insert(plus_menu, entry)
                    else
                        table.insert(normal_menu, entry)
                    end
                end
                local out = {}
                for _, it in ipairs(normal_menu) do table.insert(out, it) end
                if #plus_menu > 0 then
                    table.insert(out, { title = "-" })
                    for _, it in ipairs(plus_menu) do table.insert(out, it) end
                end
                return out
            end)()
        end
        return item
    end

    local function buildGestesItem()
        local item = {
            title = "Gestes",
            checked = state.gestures or nil,
                fn = function()
                state.gestures = not state.gestures
                if state.gestures then gestures.enable("all") else gestures.disable("all") end
                save_prefs()
                do_reload()
            end
        }
        if state.gestures then
                item.menu = (function()
                    local g_menu = {}
                    local function add(title, id)
                        table.insert(g_menu, { title = title, checked = gestures.is_enabled(id) or nil, fn = function()
                            if gestures.is_enabled(id) then gestures.disable(id) else gestures.enable(id) end; save_prefs(); do_reload() end })
                    end
                    -- 3 doigts
                    add("Tap (3 doigts) : Toggle sÃ©lection", "tap_selection")
                    add("Swipe gauche (3 doigts) : Onglet prÃ©cÃ©dent", "swipe_left")
                    add("Swipe droite (3 doigts) : Onglet suivant", "swipe_right")
                    add("Swipe haut (3 doigts) : Nouvel onglet", "swipe_up")
                    add("Swipe bas (3 doigts) : Fermer onglet", "swipe_down")
                    table.insert(g_menu, { title = "-" })
                    -- 4 doigts
                    add("Tap (4 doigts) : Recherche du mot", "tap_lookup")
                    add("Swipe gauche (4 doigts) : Espace prÃ©cÃ©dent", "swipe4_left")
                    add("Swipe droite (4 doigts) : Espace suivant", "swipe4_right")
                    table.insert(g_menu, { title = "-" })
                    -- 5 doigts
                    add("Swipe gauche (5 doigts) : FenÃªtre prÃ©cÃ©dente", "swipe5_left")
                    add("Swipe droite (5 doigts) : FenÃªtre suivante", "swipe5_right")
                    return g_menu
                end)()
        end
        return item
    end

    local function buildRaccourcisItem()
        local item = {
            title = "Raccourcis",
            checked = state.shortcuts or nil,
            fn = function()
                state.shortcuts = not state.shortcuts
                if state.shortcuts then shortcuts.start() else shortcuts.stop() end
                save_prefs()
                do_reload()
            end
        }
        if state.shortcuts then
            item.menu = (function()
                local s_menu = {}
                local list = shortcuts.list_shortcuts()

                local function pretty_key_from_id(id)
                    -- Special case for the at_hash binding: display as a single @/# key
                    if id == "at_hash" then return "Touche @/#" end

                    local parts = {}
                    for part in id:gmatch("[^_]+") do table.insert(parts, part) end
                    if #parts == 0 then return id end
                    local key = parts[#parts]
                    local modifiers = {}
                    for i = 1, #parts - 1 do
                        local p = parts[i]
                        if p == "ctrl" then table.insert(modifiers, "Ctrl")
                        elseif p == "cmd" then table.insert(modifiers, "Cmd")
                        elseif p == "alt" or p == "option" then table.insert(modifiers, "Alt")
                        elseif p == "shift" then table.insert(modifiers, "Shift")
                        else table.insert(modifiers, p:sub(1,1):upper() .. p:sub(2)) end
                    end
                    local keyname = key:upper()
                    if #modifiers > 0 then return table.concat(modifiers, " + ") .. " + " .. keyname end
                    return keyname
                end

                local function trim(s) return (s:gsub("^%s*(.-)%s*$","%1")) end

                for _, s in ipairs(list) do
                    local key = pretty_key_from_id(s.id)
                    local desc = trim((s.label or ""):gsub("%s*%b()",""))
                    local title = key .. " : " .. (desc ~= "" and desc or s.id)
                    local is_enabled = (shortcuts and type(shortcuts.is_enabled) == "function" and shortcuts.is_enabled(s.id)) or s.enabled
                    table.insert(s_menu, { title = title, checked = is_enabled or nil, fn = (function(id)
                        return function()
                            if shortcuts.is_enabled(id) then shortcuts.disable(id) else shortcuts.enable(id) end
                            save_prefs()
                            do_reload()
                        end
                    end)(s.id) })
                end
                return s_menu
            end)()
        end
        return item
    end

    local function buildUtilityItems()
        local items = {}
        table.insert(items, { title = "Layer + Scroll : Volume", checked = state.scroll or nil, fn = function()
            state.scroll = not state.scroll
            if state.scroll then scroll.start() else scroll.stop() end
            save_prefs()
                do_reload()
        end })
        table.insert(items, { title = "-" })
        table.insert(items, { title = "Ouvrir la configuration" , fn = function() hs.execute('open "' .. base_dir .. 'init.lua"') end })
        table.insert(items, { title = "Recharger la configuration", fn = function() do_reload() end })
        table.insert(items, { title = "-" })
        table.insert(items, { title = "Afficher la console", fn = function() hs.openConsole() end })
        table.insert(items, { title = "PrÃ©fÃ©rences Hammerspoon", fn = function() hs.openPreferences() end })
        table.insert(items, { title = "Quitter Hammerspoon", fn = function() hs.quit() end })
        return items
    end

    local function updateMenu()
        local menu_items = {}
        table.insert(menu_items, buildHotstringsItem())
        table.insert(menu_items, buildGestesItem())
        table.insert(menu_items, buildRaccourcisItem())
        for _, it in ipairs(buildUtilityItems()) do table.insert(menu_items, it) end
        -- Force a brief clear before setting the menu to ensure UI redraw
        myMenu:setMenu({})
        if hs and hs.timer and hs.timer.doAfter then
            hs.timer.doAfter(0.02, function() myMenu:setMenu(menu_items) end)
        else
            myMenu:setMenu(menu_items)
        end
    end

    updateMenu()

    -- reloader (watches the real source directory)
    local function reloadConfig(files)
        local doReload = false
        for _, file in pairs(files) do
            if file:sub(-4) == ".lua" then
                doReload = true
                break
            end
        end
        if doReload then do_reload("watcher") end
    end
    local configWatcher = pathwatcher.new(base_dir, reloadConfig):start()

    -- keep references to avoid GC closing the menu
    M._menu = myMenu
    M._watcher = configWatcher
    M._icon = icon

    hs.alert.show("Hammerspoon prÃªt ! ðŸš€")

    return myMenu, configWatcher
end

return M
